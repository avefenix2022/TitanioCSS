<!DOCTYPE html>
<html lang="es">
<head>

  <!-- Basic Page Needs
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta charset="utf-8">
  <title>Your page title here :)</title>
  <meta name="description" content="">
  <meta name="author" content="">

  <!-- Mobile Specific Metas
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- FONT
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link href="//fonts.googleapis.com/css?family=Raleway:400,300,600" rel="stylesheet" type="text/css">

  <!-- CSS
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="stylesheet" href="css/normalize.css">
  
  <link rel="stylesheet" href="css/skeleton-dist.css">
  
  <link rel="stylesheet" href="css/main.css">




  <!-- FAVICON
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <link rel="icon" type="image/png" href="images/favicon.png">

</head>
<body>


<!-- --- CONTAINER–––––––––––––––––––––––––––––––––––––––––––––––––– -->
  <div class="container">
  
<!-- --- ROW --------------------------------------------------------------- -->  
    <div class="row">
     
<!-- --- COLUMNA IZQUIERDA ------------------------------------------------- -->     
      <div class="one-half column" style="margin-top: 25%">
        <h4>Rápido y Ligero</h4>
        <p>14 Reglas x Web Sites de Carga Veloz</p>
        <ul>
            <li>Mínimas peticiones Http</li>
            <li>Usar CDNs</li>
            <li>Añadir caducidad al encabezado</li>
            <li>Gzip componentes</li>
            <li>Poner las hojas de estilo en el header</li>
            <li>Mover los scripts al final del archivo</li>
            <li>Evitar expresiones Css</li>
            <li>Hacer Js y Css externos</li>
            <li>Reducir CDNs</li>
            <li>Minificar Js</li>
            <li>Evitar redirecciones</li>
            <li>Eliminar scripts duplicados</li>
            <li>Configurar ETags</li>
            <li>Hacer AJAX cacheable</li>
        </ul>
        </div><!-- --- FIN COLUMNA IZQUIERDA ------------------------------- --> 





    
 <!-- --- COLUMNA DERECHA -------------------------------------------------- -->       
      <div class="one-half column" style="margin-top: 25%">
        <h4>Basic Page</h4>
        <p>This index.html page is a placeholder with the CSS, font and favicon. It's just waiting for you to add some content! If you need some help hit up the <a href="http://www.getskeleton.com">Skeleton documentation</a>.</p>
      </div><!-- --- FIN COLUMNA DERECHA ----------------------------------- -->  
         
    </div><!-- --- FIN ROW ------------------------------------------------- --> 
    
    
    
<!-- --- ROW --------------------------------------------------------------- -->    
      <div class="row">
      <div class="twelve column" style="margin-top: 8rem">
       
        <h1 class="color-salmon">Nuestro Framework Titanio CSS</h1>
        <p>Nos basamos en el framework Skeleton: <a href="http://getskeleton.com">getskeleton.com</a>. Con una anchura para el contenido de <strong>960px</strong>.</p> 
        <br>Por media queries:
        <ul>
            <li>por debajo de <strong>550px</strong> se apila el contenido, con una anchura del contenido del <strong>100%</strong>,</li>
            <li>entre <strong>400 y 500px</strong> esta anchura es del <strong>85%</strong> ,</li>
            <li>y por encima de los <strong>550px</strong> del <strong>80%</strong>.</li>
        </ul>
         
        
      </div>
      
   
    </div><!-- --- FIN ROW ------------------------------------------------- -->  
    
    
  </div><!-- --- FIN CONTAINER---------------------------------------------- -->
  
  
  
  
  
  
  
  
  <div class="cover">
      
      <h1 class="color-salmon">Titanio.css</h1>
      <h2 class="color-esmeralda">Ligero y Resistente</h2>
      
  </div>
  
  
  
  
   
    
     
       
<div class="container">
    
      <div class="row">
      <div class="twelve column" style="margin-top: 8rem">
      
      
      <!------------------------------------------------------------------------->
      
    <h1 class="color-salmon">Guía de Estilo para CSS</h1>
    <p>Las guías de estilo se deben:</p>
    <ul>
        <li>comprender,</li>
        <li>aprender, y</li>
        <li>aplicar siempre</li>
    </ul>
     <p>y cualquier desviación debe ser justificada.</p>
    <p><small>(Basada en <a href="http://cssguidelin.es/">http://cssguidelin.es/)</a></small></p>
     
      
      
      
      
     
      
        
      <h2 class="color-esmeralda">Sintaxis y formato del documento</h2>
      <p><strong>El código debe de ser y parecer limpio</strong></p>
      
      
      
      
      
      
      
      
      <h2 class="color-esmeralda">Reglas</h2>
      <ul>
          <li><strong>(4) espacios</strong> para indentar, no tabular.</li>
          <li>Columna de <strong>80 caracteres</strong> de ancho.</li>
          <li>CSS multilínea.</li>
          <li><strong>Orden alfabético.</strong></li>
          <li>Una columna para la propiedad y otra para el valor.</li>
          <li>Uso de espacios en blanco para facilitar la lectura.</li>
      </ul>
      <pre>
      
.baz {
    background-color:      green;
    color:                 red;
    display:               block;
}
     </pre>
     
     
     
     
     
     
     
     
     <h2 class="color-esmeralda">Varios archivos Css</h2>
     <p>Es una buena idea dividir trozos discretos de código css en archivos independientes para posteriormente procesarlos y concatenarlos en un archivo único.</p>

    
    
    
    
    
     
         
     <h2 class="color-esmeralda">Tabla de contenido</h2>
     <p>Una tabla de contenidos marca un esqueleto sobre el que apoyar la estructura del documento. </p>
     
     <pre>
         
/**
 
* TABLA DE CONTENIDO
*
* AJUSTES
* Global ................. Variables y configuraciones disponibles Globalmente.
* Tipografías
* Estilos Base
*
* HERRAMIENTAS
* Mixins ................. Mixins útiles.
*
* GENÉRICO
* Normalize.css .......... Normalize.
* Box-sizing ............. Box-sizing.
*
* BASE
* Encabezamientos ........ H1-H6.
*
* OBJETOS
* Contenedores ........... Contenedores.
* Grid ................... Regilla de maquetación de 12 columnas
*
* COMPONENTES
* Cabecera de las Página . Encabezado principal de la página.
* Pies de las Página ..... El pie de página.
* Botones ................ Elementos Button.
* Links .................. Etiquetas a.
* Forms .................. Formularios.
* Lists .................. Listas ordenadas y no ordenadas.
* Code ................... Etiqueta pre y code.
* Tables ................. Estilos de tablas.
* Spacing ................ Separaciones y espacios.
* Utilities .............. Diferentes utilidades.
* Clearing ............... Para limpiar float.
* 
* MEDIA QUERIES
*
* Para menores de 400px */
* ...
*
* Mayor que Móviles de 400px */
* @media (min-width: 400px) {}
*
* Mayor que Phablet de 550px (También el punto cuando empieza a activarse el grid) */
* @media (min-width: 550px) {}
*
* Mayor que Tablet */
* @media (min-width: 750px) {}
*
* Mayor que Ordenador */
* @media (min-width: 1000px) {}
*
* Mayor que Ordenadorp HD */
* @media (min-width: 1200px) {}

**/
     </pre>

     
     
     

     
          
                    
     <h2 class="color-esmeralda">Ancho de 80 caracteres</h2>
     <p>Siempre que sea posible, la anchura de los archivos css se limitará a 80 caracteres. Las razones para esto incluyen:
     </p>
     <ul>
         <li>Capacidad para abrir varios documentos uno al lado del otro.</li>
         <li>Visualizar los archivos css en sitios como GitHub y ventanas de terminal.</li>
         <li>Proporcionar una longitud de línea cómoda para comentarios.</li>
     </ul>
     <pre>
         
/ **
* Este es el tamaño de un comentario con una longitud de 80 catacteres de ancho.
*
* Lorem ipsum dolor sit amet, consectetur adipisicing elit. Numquam dignissimos 
* facilis eveniet, incidunt voluptatem sit soluta maiores qui ducimus blanditiis
* impedit autem dolorum, cum veritatis ratione ut. Debitis, hic repellendus.
** /
     </pre>
     
     
     
     

     
          
     
     <h2 class="color-esmeralda">Títulos</h2>
     <p><strong>Comenzar cada nueva sección principal con un título</strong></p>
     <pre>
         
/*------------------------------------*\
    #SECTION-TITLE
\*------------------------------------*/

.selector {}
     </pre>
     
     <p>El título de la sección está <strong>precedido de un símbolo de almohadilla (#) que nos permita realizar búsquedas más específicas</strong>. En lugar de buscar simplemente SECCIÓN-TITULO que pueden producir muchos resultados que una búsqueda más restringida de <strong>#SECCIÓN-TÍTULO</strong> la cual debería devolver solo la sección en cuestión.</p>
     
     <p><strong>Dejar un retorno de carro entre este título y la siguiente línea de código.</strong></p>
     <p>Si está trabajando en un proyecto en el que cada sección es su propio archivo, este título debería aparecer en la parte superior de cada uno de ellos. Si está trabajando en un proyecto con varias secciones por archivo, <strong>cada título debe ir precedido de cinco (5) retornos de carro</strong>. Este espacio en blanco adicional junto con un título hace que las nuevas secciones sean mucho más fácil de detectar cuando uno se desplaza a través de archivos de gran tamaño:</p>
     <pre>
     
/*------------------------------------*\
    #A-SECTION
\*------------------------------------*/

.selector {}
1
2
3
4
5
/*------------------------------------*\
    #ANOTHER-SECTION
\*------------------------------------*/

/**
 * Comment
 */

.another-selector {}
     </pre>
      
      
      
      
      
      <h2 class="color-esmeralda">Anatomía de un conjunto de reglas</h2>
      <p>Antes de discutir la forma en que escribimos conjuntos de reglas, primero vamos a familiarizarnos con la <strong>terminología</strong>:</p>
      
      <pre>
      
[selector] {
    [propiedad]: [valor];
    [<--declaracion--->]
}
      </pre>
      
      <p>Por ejemplo:</p>
      
      <pre>    
.foo, .foo--bar, 
.baz {
    display:               block;
    background-color:      green;
    color:                 red;
}
      </pre>
      
      

      
      <ul>
          <li>Selectores relacionados en la misma línea; no relacionados en nuevas líneas.</li>
          <li>Un espacio antes de abrir unas llaves ' {'</li>
          <li>Propiedades y valores en la misma línea.</li>
          <li>Al menos un espacio después de lo dos punto (:)</li>
          <li>Propiedades y valores en dos columnas.</li>
          <li>Cada declaración en una nueva línea.</li>
          <li>La llave de apertura ({) en la misma línea que el último selector.</li>
          <li>La primera declaración en una nueva línea después de nuestra llave de apertura ({)</li>
          <li>La llave de cierre (}) en su propia línea nueva.</li>
          <li>la sangría de cada declaración con <strong>cuatro (4)</strong> espacios;</li>
          <li>Un punto y coma (;) al fina de nuestra última declaración (aunque no sea obligatoria).</li>
          <li>Los valores <strong>siempre con unidades</strong> incluso los de valor '0'.</li>
      </ul>
      
  
      
      
      
      <h2 class="color-esmeralda">CSS Multi-línea</h2>
      <p>El CSS debe ser escrito en <strong>múltiples líneas</strong>, excepto en circunstancias muy específicas.<br>
      <strong>Hay ventajas para esto, como con conjuntos de reglas similares, que solo llevan una declaración, por ejemplo</strong>:</p>
      
      <pre>

.icon {
    display: inline-block;
    width:  16px;
    height: 16px;
    background-image: url(/img/sprite.svg);
}

.icon--home     { background-position:   0     0  ; }
.icon--person   { background-position: -16px   0  ; }
.icon--files    { background-position:   0   -16px; }
.icon--settings { background-position: -16px -16px; }
      </pre>
      
      <p><strong>Cuando la presentación en una sola línea proporciona mejor la información por simplicidad y comparación se puede codificar en una sola línea.</strong></p>
      
      
      
      
      
      <h2 class="color-esmeralda">Sangría</h2>
      <p>Se pueden sangrar selectores con sus declaraciones para indicar relaciones entre ellos:</p>
      
      <pre>
          
.foo {}

    .foo__bar {}

        .foo__baz {}
      </pre>
      
      <p>De esta manera, un desarrollador puede ver a simple vista que <code>.foo__baz {}</code> vive en el interior de <code>.foo__bar {}</code> y este vive dentro <code>.foo {}</code>.</p>
      <p>Esta cuasi-replicación del DOM le dice a los desarrolladores mucho acerca de donde se espera que las clases van a ser utilizadas sin que tengan que hacer referencia a un fragmento de código HTML.</p>
      
      
      
      
      
      <h2 class="color-esmeralda">Sangría Sass</h2>
      <p>Sass proporciona una funcionalidad de anidación (<strong>nesting</strong>), como esta:</p>
      
      <pre>

.foo {
    color: red;

    .bar {
        color: blue;
    }

}
      </pre>
      
      <p>Que se compilará a:</p>
      
      <pre>
          
.foo { color: red; }
.foo .bar { color: blue; }
      </pre>
      
      <p>Cuando sangramos en Sass, nos ceñimos a los mismos cuatro (4) espacios, y también dejar una línea en blanco antes y después del conjunto de reglas anidadas.</p>
      
      <p><strong>La anidación en Sass debe evitarse siempre que sea posible, por especificidad!</strong></p>
      
      
      
      
      
      <h2 class="color-esmeralda">Alinear</h2>
      <p>Intentar alinear cadenas idénticas y relacionadas en las declaraciones, por ejemplo:</p>
      
      <pre>
          
.foo {
    -webkit-border-radius: 3px;
       -moz-border-radius: 3px;
            border-radius: 3px;
}

.bar {
    position:              absolute;
    top:                   0;
    right:                 0;
    bottom:                0;
    left:                  0;
    margin-right:          -10px;
    margin-left:          -10px;
    padding-right:        10px;
    padding-left:         10px;
}
      </pre>
      
      
      
      
      
      <h2 class="color-esmeralda">Significado de los espacios en blanco</h2>
      <p>Podemos proporcionar una gran cantidad de información mediante el uso libre y juicioso de espacios en blanco entre los conjuntos de reglas. <br> Utilizamos:</p>
      <ul>
          <li><strong>Una (1)</strong> línea vacía entre los conjuntos de reglas estrechamente relacionados.</li>
          <li><strong>Dos (2)</strong> líneas vacías entre los conjuntos de reglas vagamente relacionados.</li>
          <li><strong>Cinco (5)</strong> líneas vacías entre secciones.</li>
      </ul>
      <p>Por ejemplo:</p>
      <pre>
          
/*------------------------------------*\
    #FOO
\*------------------------------------*/

.foo {}

    .foo__bar {}


.foo--baz {}





/*------------------------------------*\
    #BAR
\*------------------------------------*/

.bar {}

    .bar__baz {}

    .bar__foo {}
      </pre>
      
      
      
      
      
      <h2 class="color-esmeralda">Marcado HTML</h2>
      <p>Con los <strong>atributos</strong>:</p>
      
      <pre>
        
&lt;div class="box"&gt;
      </pre>
      
      <p>Al escribir varios valores en un atributo de clase, hay que separarlos con <strong>dos (2)</strong> espacios:</p>
      
      <pre>
        
&lt;div class="foo  bar"&gt;
      </pre>
      
      <p>Cuando hay <strong>varias clases que están relacionadas entre sí, podrá agruparlas entre corchetes ([ y ])</strong>, así:</p>
      
      <pre>
          
&lt;div class="[ box  box--highlight ]  [ bio  bio--long ]"&gt;
      </pre>
      
      <p><a href="http://csswizardry.com/2014/05/grouping-related-classes-in-your-markup/">Leer más+</a></p>
      
      <p>Al igual que con nuestros conjuntos de reglas CSS, es posible utilizar los espacios en blanco de forma significativa en el código HTML. Puede denotar <strong>descansos temáticos en el contenido</strong> con <strong>cinco (5)</strong> líneas vacías, por ejemplo:</p>
      
      <pre>         
&lt;header class="page-head"&gt;
    ...
&lt;/header&gt;





&lt;main class="page-content"&gt;
    ...
&lt;/main&gt;





&lt;footer class="page-foot"&gt;
    ...
&lt;/footer&gt;
      </pre>
      
      <p>Para <strong>fragmentos independientes</strong>, pero vagamente relacionados el marcado es con <strong>una sola línea</strong> en blanco, por ejemplo:</p>
      
      <pre>
          
&lt;ul class="primary-nav"&gt;

    &lt;li class="primary-nav__item"&gt;
        &lt;a href="/" class="primary-nav__link"&gt;Home&lt;/a&gt;
    &lt;/li&gt;

    &lt;li class="primary-nav__item  primary-nav__trigger"&gt;
        &lt;a href="/about" class="primary-nav__link"&gt;About&lt;/a&gt;

        &lt;ul class="primary-nav__sub-nav"&gt;
            &lt;li&gt;&lt;a href="/about/products"&gt;Products&lt;/a&gt;&lt;/li&gt;
            &lt;li&gt;&lt;a href="/about/company"&gt;Company&lt;/a&gt;&lt;/li&gt;
        &lt;/ul&gt;

    &lt;/li&gt;

    &lt;li class="primary-nav__item"&gt;
        &lt;a href="/contact" class="primary-nav__link"&gt;Contact&lt;/a&gt;
    &lt;/li&gt;

&lt;/ul&gt;
      </pre>
      
      <p>Esto permite a los desarrolladores detectar <strong>partes separadas del DOM de un vistazo</strong>.</p>
      
      
      
      
      
      <h2 class="color-esmeralda">Comentarios</h2>
      <p>La sobrecarga cognitiva de trabajar con CSS es enorme. Con tantos matices que dificulta ser consciente de todos, y más de los específicos de cada proyecto, la peor situación que la mayoría de los desarrolladores se encuentran es que no son la persona que escribió el código. Estas pueden recordar sus propias clases, reglas,... que es manejable hasta cierto punto, pero cualquier persona que hereda CSS apenas tiene posibilidades.</p>
      <p>El CSS necesita más comentarios.</p>
      <p>Como regla general, se debe comentar cualquier cosa que no sea evidente a partir solo del código. Es decir, no hay necesidad de decirle a alguien que color: red; colorea la fuente de rojo, pero si se está utilizando overflow: hidden; para borrar los desbordamientos -en contraste con un elemento con desbordamiento, esto es probablemente algo que vale la pena documentar.</p>
      
      <p>Para grandes comentarios que documentan secciones o componentes enteros, usamos un comentario de varias líneas de ancho de <strong>80</strong> columnas. Por ejemplo:</p>
      
      <pre>
          
/**
 * La cabecera de la página principal tiene dos estados:
 *
 * 1) Cabecera de la página normal sin imagenes de fondo. Solo contiene el logo
 * y el menu de navegación.
 * 2) Cabecera de la página con imagen de fondo cover y etiquetas de cabecera.
 *
 */
      </pre>
      
      <p>Este nivel de detalle debería ser la norma para todas las descripciones de códigos.</p>
      
      
      
      
      
      <h2 class="color-esmeralda">Extensión de reglas</h2>
      <p>Cuando trabajamos con el patrón OOCSS, con reglas que pueden estar relacionadas incluso en archivos diferentes se deben de indicar estas extensiones.</p>
      <p>En el archivo del objeto:</p>
      
      <pre>
        
/**
 * Extiende `.btn {}` en _components.buttons.scss.
 */

.btn {}
      </pre>
      
      <p>Y en el archivo del Tema:</p>
      
      <pre>
          
/**
 * Estas reglas extienden `.btn {}` en _objects.buttons.scss.
 */

.btn--positive {}

.btn--negative {}
      </pre>
      
      <p>La existencia de este sencillo comentario que requiere poco esfuerzo,  puede proporcionar una ventaja para los desarrolladores que desconocen de dónde heredan los estilos.</p>

      

      
  
      <h2 class="color-esmeralda">Comentarios del preprocesador</h2>
      <p>Con la mayoría, si no todos lo pre-procesadores, tenemos la opción de escribir comentarios que no serán compilados a nuestro fichero CSS resultante. Como regla general,  se debe de usar estos comentarios para documentar código que afecte al archivo precompilado y que no va a aparecer escrito en el archivo CSS porque allí no se aplica. Si se está documentando código que se compila, utilizar los comentarios que se compilará también. Por ejemplo, esto es correcto:</p>
      
      <pre>
          
// Dimensiones de imágnes @2x:
$sprite-width:  920px;
$sprite-height: 212px;

/**
 * 1. Tamaño por defecto de icono 16px.
 * 2. Retina sprite se muestra en el tamaño correcto.
 */
.sprite {
    width:  16px; /* [1] */
    height: 16px; /* [1] */
    background-image: url(/img/sprites/main.png);
    background-size: ($sprite-width / 2 ) ($sprite-height / 2); /* [2] */
}
      </pre>
      
      <p>Hemos comentado las variables, las cuales no se muestran en nuestro archivo CSS junto con estos comentarios, mientras que nuestro código CSS que se compila en el archivo CSS se documenta el uso final del CSS compilado con comentarios. Esto significa que sólo tenemos la información correcta y relevante a nuestra disposición al depurar nuestras hojas de estilo compiladas.</p>
      
      
      
      
      
      <h2 class="color-esmeralda">Eliminar comentarios</h2>
      <p>No hace falta decir que en el <strong>entorno de producción</strong> no deben de aparecer estos comentarios. <strong>Todos los CSS deben de ser minificados</strong> lo que conlleva la pérdida de estos comentarios antes de ser desplegados los archivos.</p>
      
      
      
      
      
      <h2>Convenios de Nombres</h2>
      <p>Tener una convención en los nombres en las denominaciones CSS son muy útilies para hacer el código más estricto, transparente e informativo.</p>
      <p>Una buena convención de nombres debe de comunicarte a tí y tu euipo:</p>
      <ul>
          <li>Qué tipo de cosa hace una clase</li>
          <li>Dónde una clase debe de ser utilizada</li>
          <li>Con qué una clase podría estar realcionada</li>
      </ul>
      <p>La convención de nombres es muy simple: un guión (-) para delimitar cadenas, y con la denominación BEM para piezas más complejas de código.</p>
      <p>Vale la pena señalar que una convención de nombres no es normalmente útil del lado del desarrollo CSS, son útilies cuando se ven con el HTML.</p>
      
      
      
      
      
      <h2>Delimitador guión</h2>
      <p>Todas las cadenas de las clases están delimitadas con un guión (-), así:</p>
      
      <pre>
          
.page-head {}

.sub-content {}
      </pre>
      
      <p>Camel case y guiones bajos no son utilizados. Lo siguiente es incorrecto:</p>
      
      <pre>
          
.pageHead {}

.sub_content {}
      </pre>
      
      
      
      
      
      <h2>Nombrar como BEM</h2>
      <p>A mayores para componentes interrelacionados de la interfaz de usuario que requiere un número mayor de clases, se utiliza la convención de nomenclatura similar a BEM.</p>
      <p>BEM, bloque, elemento, modificador, es una metodología de front-end acuñada por los desarrolladores que trabajan en Yandex. Mientras BEM es una metodología completa, aquí sólo nos interesa su convención de nombres. Además, la convención de nombres aquí solamente es como BEM; los principios son exactamente los mismos, pero la sintaxis real difiere ligeramente.</p>
      <p>BEM divide clases de componentes en tres grupos:</p>
      <ul>
          <li>Bloque: La única raíz del componente.</li>
          <li>Elemento: un componente del bloque.</li>
          <li>Modificador: Una variante o extensión del bloque.</li>
      </ul>
      
      <pre>
        
.person {}
.person__cabeza {}
.person--alto {}
      </pre>
      
      <p>Los elementos son delimitados con dos (2) guiones bajos (__) y los modificadores con dos (2) guiones (--).</p>
      <p>Aquí podemos ver que <code>.person {}</code> es el bloque; es la única raíz de una entidad discreta. <code>.person__cabeza {}</code> es un elemento; que es una parte más pequeña del bloque <code>.person {}</code>. Por último, <code>.person--alto {}</code> es un modificador; se trata de una variante específica del bloque <code>.person {}</code>.</p>
      
      
      
      
      
      <h2>Contexto de partida</h2>
      <p>Su contexto de bloque comienza en el auto-contenido, la ubicación discreta más lógica. Para continuar con nuestra analogía basada en la persona, no tendríamos una clase como persona como .room_ {}, ya que la habitación es otro contexto mucho más alto. Probablemente tendríamos bloques separados, de este modo:</p>
      
      <pre>
          
.room {}

    .room__door {}

.room--kitchen {}


.person {}

    .person__head {}
      </pre>
      
      <p>Si queríamos denotar una <code>.person {}</code> dentro de un <code>.room {}</code>, es más correcto utilizar un selector como <code>.person .room {}</code> que une dos bloques para aumentar el alcance de bloques y elementos existentes.</p>
      <p>Un ejemplo más realista de bloques con ámbito podría ser algo como esto, donde cada trozo de código representa su propio bloque:</p>
      
      <pre>
          
.page {}


.content {}


.sub-content {}


.footer {}

    .footer__copyright {}
      </pre>
      
      <p>Una notación incorrecta para esto sería:</p>
      
      <pre>
          
.page {}

    .page__content {}

    .page__sub-content {}

    .page__footer {}

        .page__copyright {}
      </pre>
      
      <p>Es importante saber cuándo se inicia y se detiene el alcance de BEM. Como regla general, se aplica BEM a partes autónomas, partes discretas de la interfaz de usuario.</p>
      
      
      
      
      
      <h2>Más capas</h2>
      <p>Si tuviéramos que añadir otro elemento digamos <code>.person__eye {}</code> para este componente <code>.person {}</code>, <strong>no tendría que pasar por todas las capas de la DOM</strong>. Es decir, la notación correcta sería <code>.person__eye {}</code>, y no <code>.person__head__eye {}</code>. Sus clases no reflejan el papel completo de la ruta del DOM.</p>
      
      
      
      
      
      <h2>Modificación de Elementos</h2>
      <p>Usted puede tener variantes de elementos, y estos pueden ser denotado en un número de maneras, dependiendo de cómo y por qué se están modificando. Continuando con nuestro ejemplo de persona, un ojo azul podría tener este aspecto:</p>
      
      <pre>
          
.person__eye--blue {}
      </pre>
      
      <p>Aquí podemos ver que estamos directamente modificando el elemento ojo.</p>
      <p>Sin embargo las cosas pueden ser más complejas. Por favor, disculpe la cruda analogía, y vamos a imaginar que tenemos un elemento de cara que es guapo. La persona en sí no es tan guapo, así que modificamos el elemento cara directamente, un rostro hermoso en una persona normal:</p>
      
      <pre>
          
.person__face--handsome {}
      </pre>
      
      <p>Pero ¿y si esa persona es guapa, y queremos que el estilo de su cara? Un rostro habitual en una hermosa persona:</p>
      
      <pre>
          
.person--handsome .person__face {}
      </pre>
      
      <p>Esta es uno de las pocos ocasiones en donde utilizar un selector descendiente que modifica un elemento basado en un modificador de un bloque.</p>
      
      <p>Si se utiliza Sass, escribiríamos algo como esto:</p>
      
      <pre>
          
person {}

    .person__face {

        .person--handsome & {}

    }

.person--handsome {}
      </pre>
      
      <p>Tenga en cuenta que no anida una nueva instancia de .person__face {} dentro de .person--handsome {}; en lugar de esto, hacemos uso del selector padre de Sass que antepone .person--handsome a .person__face. Esto significa que todas nuestras reglas  relativas a .person__face están en un solo lugar, y no se extienden por todo el archivo. Esta es una buena práctica general cuando se trata de código anidado: mantener la totalidad de su contexto (por ejemplo, todo el código .person__face {}) encapsulado en un solo lugar.</p>
      
      
      
      
      
      <h2>Convenciones de nombres en HTML</h2>
      <p>Como comentamos previamente, las convenciones de nombres no son necesariamente útilies en el CSS. Donde la convención de nombres muestra su poder es en el marcado. Tomando el siguiente HTML con nombrado-no-convencional:</p>
      
      <pre>
          
&lt;div class="box  profile  pro-user"&gt;

    &lt;img class="avatar  image" /&gt;

    &lt;p class="bio"&gt;...&lt;/p&gt;

&lt;/div&gt;
      </pre>
      
      
      <p>¿Cómo está el cuadro de clases y el perfil relativo a cada una? ¿Cómo están las clases de perfil y avatar relacionadas con otras? Están relacionadas con todos? Dede de ser usado pro-user al lado de bio? ¿La clase image y profile viven en la misma parte del CSS? ¿Se puede utilizar avatar en otro sitio?</p>
      <p>Es muy difícil responder a cualquiera de estas preguntas. El uso de una convención de nombres, sin embargo, cambia todo eso:</p>
      
      <pre>
          
&lt;div class="box  profile  profile--is-pro-user"&gt;

    &lt;img class="avatar  profile__image" /&gt;

    &lt;p class="profile__bio"&gt;...&lt;/p&gt;

&lt;/div&gt;
      </pre>
      
      <p>Ahora podemos ver claramente que clases estan y no relacionados entre sí y cómo; sabemos qué clases no se puede utilizar fuera del alcance de este componente; y sabemos qué clases pueden ser libres de reutilizar en otro lugar.</p>
      
      
      
      
      
      <h2>Selectores CSS</h2>
      <p>Es importante a la hora de escribir CSS que tenemos correctamente el alcance de nuestros selectores, y que estamos seleccionando las cosas correctas por las razones correctas.</p>
      <p>Hay quede decidir y definir lo que quiere el estilo y cómo va a seleccionarlo.</p>
      <p>Por ejemplo, si estás interesado en el estilo de menú de navegación principal de su sitio web, un selector que esto sería muy poco inteligente:</p>
      
      <pre>
          
header ul {}
      </pre>
      
      <p>Este selector da estilo a cualquier <code>ul</code> dentro de cualquier elemento <code>header</code> mientras que nuestra intención era el estilo del navegación del sitio principal</p>
      <p>Una mejor aproximación es:</p>
      
      <pre>
          
.site-nav {}
      </pre>
      
      <p>Estamos seleccionando explícitamente lo correcto, exactamente por la razón correcta.</p>
      <p><strong>Los selectores deben ser lo más explícitos posible y bien razonado como tu razón para querer seleccionar algo.</strong></p>
      
      
      
      
      
      <h2>Reutilización</h2>
      <p>Con un movimiento hacia un enfoq basado más en componentes para la construcción de interfaces de usuario, la idea de reutilización es de suma importancia.</p>
      <p>Por esta razón <strong>hecemos un uso intensivo de las <code>.clases</code></strong></p>
      <p>Los IDs son demasiado específico, no se pueden utilizar más de una vez en una página.</p>
      <p><strong>Todo lo que elija, desde el tipo de selector a su nombre, debería prestarse a ser reutilizado.</strong></p>
      
      
      
      
      
      
      <h2>Ubicación independiente</h2>
      <p>Dada la naturaleza siempre cambiante de la mayoría de los proyectos de interfaz de usuario, y el paso a más arquitecturas basadas en componentes, es de nuestro interés no el estilo de las cosas basadas en dónde están, sino en lo que son. Es decir, al diseñar nuestros componentes deberían permanecer completamente independiente de la ubicación.</p>
      <p>Tomemos un ejemplo de un botón de llamada a la acción que hemos optado por el estilo a través de la siguiente selector:</p>
      
      <pre>
          
.promo a {}
      </pre>
      
      <p>Este selector está demasiado ligado a su ubcación. Un mejor selector sería:</p>
      
      <pre>
          
.btn {}
      </pre>
      
      <p>Esta clase puede ser reutilizada en cualquier lugar fuera de .promo y siempre llevar su estilo correcto. Como resultado de un selector mejor, esta pieza de la interfaz de usuario es más portátil, más reciclables, no tiene ninguna dependencia, y define mucho mejor la intención del selector.</p>
      
      
      
      
      
      <h2>Portabilidad</h2>
      <p>La reducción, o idealmente, eliminación de las dependencia de la ubicación significa que podemos mover los componentes con más libertad.</p>
      
      <pre>
          
input.btn {}
      </pre>
      
      <p>permite volver a utilizar la clase .btn sobre cualquier elemento que elegimos, al igual que una a, por ejemplo, o un botón.</p>
      <p>Por supuesto, hay ocasiones en las que usted puede desear un selector-puede que tenga que aplicar un  estilo muy específico para un elemento en particular, por ejemplo:</p>
      
      <pre>
          
/**
 * Embolden and colour any element with a class of `.error`.
 */
.error {
    color: red;
    font-weight: bold;
}

/**
 * If the element is a `div`, also give it some box-like styling.
 */
div.error {
    padding: 10px;
    border: 1px solid;
}
      </pre>
      
      <p>Este es un ejemplo donde un selector cualificado podría ser justificable, pero aun así, recomendaría un enfoque más como:</p>
      
      <pre>
          
/**
 * Text-level errors.
 */
.error-text {
    color: red;
    font-weight: bold;
}

/**
 * Elements that contain errors.
 */
.error-box {
    padding: 10px;
    border: 1px solid;
}
      </pre>
      
      <p>Significa que podemos aplicar <code>.error-box</code> a cualquier elemento, y no sólo a un <code>div</code>, es más reutilizable que un selector cualificado.</p>
      
      
      
      
      
      
      
      <h2>Selectores cuasi-calificados</h2>
      <p>Una cosa para la que los selectores calificados pueden ser útiles es para la señalización donde se podría esperar que una clase sea utilizada, por ejemplo:</p>
      
      <pre>
          
ul.nav {}
      </pre>
      
      <p>Aquí podemos ver que la clase .nav está destinado a ser utilizado en un elemento ul, y no en un nav. Mediante el uso de selectores cuasi-calificado aún podemos proporcionar esa información sin tener que calificar el selector:</p>
      
      <pre>
          
/*ul*/.nav {}
      </pre>
      
      <p>Comentando el elemento que lo lleva, dejamos que se pueda leer, pero evite la calificación y el aumento de la especificidad del selector.</p>
      
      
      <h2>Naming</h2>
      <p>Como dijo una vez Phil Karlton:</p> 
      <blockquote>"...sólo hay dos cosas duras en la Ciencias de la Computación: invalidación de caché y nombrar las cosas..."<cite> --Phil Karlton.</cite></blockquote>
      <p>Mi consejo con respecto a nombrar las cosas en CSS es escoger un nombre sensible, pero que aspire a la máxima capacidad de reutilización. Por ejemplo, en lugar de una clase como <code>.site-nav</code>, elegir algo así como <code>.primary-nav</code> en lugar de <code>.footer-links</code>, favorecer a una clase como <code>.sub-links</code>.</p>
      <p>Las diferencias en estos nombres es que el primero de cada ejemplo está vinculado a un caso de uso muy específico: sólo se puede utilizar como la navegación del sitio o los enlaces de pie de página, respectivamente.</p>
      <p>Mediante el uso de nombres más ambiguas, podemos aumentar nuestra capacidad de reutilizar estos componentes en diferentes circunstancias.</p>
      <p>Para citar a Nicolas Gallagher:</p>
      <blockquote>"...Atar la semántica de las clase estrechamente a la naturaleza del contenido ha reducido la capacidad de arquitectura a escala o de ser fácilmente utilizada por otros desarrolladores..." <cite> --Nicolas Gallagher</cite></blockquote>
      <p>Es decir, debemos utilizar nombres coherentes de clases, pero hay que evitar el uso de clases que describen la naturaleza exacta de uso de contenido. <strong>El uso de un nombre de clase para describir el contenido es redundante ya que el contenido se describe a sí mismo.</strong></p>
      <p>El debate en torno a la semántica se ha prolongado durante años, pero es importante que adoptemos un enfoque más pragmático, sensible a nombrar las cosas con el fin de trabajar de manera más eficiente y eficaz. En lugar de centrarse en «semántica», mira más de cerca a la sensibilidad y la longevidad, elegir nombres basado en la facilidad de mantenimiento, no por el significado percibido.</p>
      <p>Nombrar las cosas para la gente; que son los únicos que realmente leen sus clases (todo lo demás simplemente les coincide). Una vez más, es mejor luchar por clases reutilizables, reciclables en lugar de escribir para casos de uso específicos. Tomemos un ejemplo:</p>
      
      <pre>
          
/**
 * Runs the risk of becoming out of date; not very maintainable.
 */
.blue {
    color: blue;
}

/**
 * Depends on location in order to be rendered properly.
 */
.header span {
    color: blue;
}

/**
 * Too specific; limits our ability to reuse.
 */
.header-color {
    color: blue;
}

/**
 * Nicely abstracted, very portable, doesn’t risk becoming out of date.
 */
.highlight-color {
    color: blue;
}
      </pre>
      
      <p>Es importante encontrar un equilibrio entre los nombres que no describen literalmente el estilo que trae la clase, sino también a los que no se describen explícitamente los casos de uso específicos. En lugar de .home páginas de pantalla, seleccione .masthead; en lugar de .site-nav, favorecer .primary-nav; en lugar de .btn-entrada, optar por .btn-primaria.</p>
      
      
      
      
      <h2>Nombrando Componentes de la Interfaz de Usuario</h2>
      <p>Nombrar componentes con la reutilización en mente realmente ayuda a los desarrolladores a construir y modificar las interfaces de usuario mucho más rápidamente. Sin embargo, a veces puede ser beneficioso proporcionar denominación más específica o significativa junto a la clase más ambiguas, en particular cuando varias clases se unen para formar un componente más complejo y específico que podría beneficiarse de tener un nombre más significativo. En este escenario, aumentamos las clases con un atributo <strong>data-ui-component</strong> que alberga un nombre más específico, por ejemplo:</p>
      
      <pre>
          
&lt;ul class="tabbed-nav" data-ui-component="Main Nav"&gt;
      </pre>
      
      <!------------------------------------------------------------------------->
      
      <h2>Referencias</h2>
      
      <a href="https://github.com/inuitcss/inuitcss">inuitcss</a>
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
      
       
        <h1>Nuestro Framework</h1>
        <p>Lorem ipsum dolor sit amet, consectetur adipisicing elit. Necessitatibus deleniti, laborum. Sint quidem id perferendis expedita ut at totam minus dicta, voluptas. Totam eius aliquid cum laudantium voluptatem provident maxime.</p>
        
        <ul>
            <li>Colores</li>
            <li></li>
            <li></li>
            <li></li>
            <li></li>
        </ul>
        
      </div>
      
   
      
    </div> 
  
    </div>
  
  
  
   <div class="container">
    
      <div class="row">
      <div class="twelve column" style="margin-top: 8rem">
       
        <h1 class="color-salmon">Colores</h1>
        <div><span class="celda celda--color-salmon"></span> <span>.celda--color-salmon</span></div>
        <div><span class="celda celda--color-salmon-claro"></span> <span>.celda--color-salmon-claro</span></div>
        <div><span class="celda celda--color-salmon-masclaro"></span> <span>.celda--color-salmon-masclaro</span></div>
        
        <div><span class="celda celda--color-esmeralda"></span> <span>.celda--color-esmeralda</span></div>
        <div><span class="celda celda--color-esmeralda-claro"></span> <span>.celda--color-esmeralda-claro</span></div>
        
        <div><span class="celda celda--color-cyan"></span> <span>.celda--color-cyan</span></div>
        <div><span class="celda celda--color-cyan-claro"></span> <span>.celda--color-cyan-claro</span></div>
        
      </div>
      
    </div> 
  
    </div>
  












<!-- End Document
  –––––––––––––––––––––––––––––––––––––––––––––––––– -->
</body>
</html>
